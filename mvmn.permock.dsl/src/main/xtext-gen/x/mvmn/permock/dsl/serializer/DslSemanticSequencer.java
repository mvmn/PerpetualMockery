/*
 * generated by Xtext 2.25.0
 */
package x.mvmn.permock.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import x.mvmn.permock.dsl.dsl.AndCondition;
import x.mvmn.permock.dsl.dsl.CollectionAccess;
import x.mvmn.permock.dsl.dsl.Condition;
import x.mvmn.permock.dsl.dsl.Constant;
import x.mvmn.permock.dsl.dsl.DslPackage;
import x.mvmn.permock.dsl.dsl.Entity;
import x.mvmn.permock.dsl.dsl.Expression;
import x.mvmn.permock.dsl.dsl.FunctionCall;
import x.mvmn.permock.dsl.dsl.Header;
import x.mvmn.permock.dsl.dsl.Headers;
import x.mvmn.permock.dsl.dsl.ListElementAlias;
import x.mvmn.permock.dsl.dsl.ListElementReference;
import x.mvmn.permock.dsl.dsl.ListFunction;
import x.mvmn.permock.dsl.dsl.Negation;
import x.mvmn.permock.dsl.dsl.Operand;
import x.mvmn.permock.dsl.dsl.OrCondition;
import x.mvmn.permock.dsl.dsl.PropertyAccess;
import x.mvmn.permock.dsl.dsl.PropertyRef;
import x.mvmn.permock.dsl.dsl.ProxyConf;
import x.mvmn.permock.dsl.dsl.Reference;
import x.mvmn.permock.dsl.dsl.ResponseConf;
import x.mvmn.permock.dsl.dsl.Rule;
import x.mvmn.permock.dsl.services.DslGrammarAccess;

@SuppressWarnings("all")
public class DslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.AND_CONDITION:
				sequence_AndCondition(context, (AndCondition) semanticObject); 
				return; 
			case DslPackage.COLLECTION_ACCESS:
				sequence_CollectionAccess(context, (CollectionAccess) semanticObject); 
				return; 
			case DslPackage.CONDITION:
				sequence_BracketedCondition(context, (Condition) semanticObject); 
				return; 
			case DslPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case DslPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case DslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case DslPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case DslPackage.HEADER:
				sequence_Header(context, (Header) semanticObject); 
				return; 
			case DslPackage.HEADERS:
				sequence_Headers(context, (Headers) semanticObject); 
				return; 
			case DslPackage.LIST_ELEMENT_ALIAS:
				sequence_ListElementAlias(context, (ListElementAlias) semanticObject); 
				return; 
			case DslPackage.LIST_ELEMENT_REFERENCE:
				sequence_ListElementReference(context, (ListElementReference) semanticObject); 
				return; 
			case DslPackage.LIST_FUNCTION:
				sequence_ListFunction(context, (ListFunction) semanticObject); 
				return; 
			case DslPackage.NEGATION:
				sequence_OptionalNegationCondition(context, (Negation) semanticObject); 
				return; 
			case DslPackage.OPERAND:
				sequence_Operand(context, (Operand) semanticObject); 
				return; 
			case DslPackage.OR_CONDITION:
				sequence_OrCondition(context, (OrCondition) semanticObject); 
				return; 
			case DslPackage.PROPERTY_ACCESS:
				sequence_PropertyAccess(context, (PropertyAccess) semanticObject); 
				return; 
			case DslPackage.PROPERTY_REF:
				sequence_PropertyRef(context, (PropertyRef) semanticObject); 
				return; 
			case DslPackage.PROXY_CONF:
				sequence_ProxyConf(context, (ProxyConf) semanticObject); 
				return; 
			case DslPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case DslPackage.RESPONSE_CONF:
				sequence_ResponseConf(context, (ResponseConf) semanticObject); 
				return; 
			case DslPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Condition returns AndCondition
	 *     OrCondition returns AndCondition
	 *     OrCondition.OrCondition_1_0 returns AndCondition
	 *     AndCondition returns AndCondition
	 *     AndCondition.AndCondition_1_0 returns AndCondition
	 *
	 * Constraint:
	 *     (left=AndCondition_AndCondition_1_0 right=OptionalNegationCondition)
	 */
	protected void sequence_AndCondition(ISerializationContext context, AndCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.AND_CONDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.AND_CONDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.AND_CONDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.AND_CONDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndConditionAccess().getAndConditionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndConditionAccess().getRightOptionalNegationConditionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *     OrCondition returns Condition
	 *     OrCondition.OrCondition_1_0 returns Condition
	 *     AndCondition returns Condition
	 *     AndCondition.AndCondition_1_0 returns Condition
	 *     OptionalNegationCondition returns Condition
	 *     BracketedCondition returns Condition
	 *
	 * Constraint:
	 *     (expression=Expression | condition=Condition)
	 */
	protected void sequence_BracketedCondition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionAccess returns CollectionAccess
	 *
	 * Constraint:
	 *     (key=STRING | index=INTEGER)
	 */
	protected void sequence_CollectionAccess(ISerializationContext context, CollectionAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     (strVal=STRING | intVal=INTEGER | floatVal=FLOAT | boolVal=BOOLEAN)
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ENTITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ENTITY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (left=Operand (op=Operator right=Operand)?)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (name=ID functionParameters+=Operand? functionParameters+=Operand*)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Header returns Header
	 *
	 * Constraint:
	 *     (headerName=STRING headerValue=STRING)
	 */
	protected void sequence_Header(ISerializationContext context, Header semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.HEADER__HEADER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.HEADER__HEADER_NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.HEADER__HEADER_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.HEADER__HEADER_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHeaderAccess().getHeaderNameSTRINGTerminalRuleCall_0_0(), semanticObject.getHeaderName());
		feeder.accept(grammarAccess.getHeaderAccess().getHeaderValueSTRINGTerminalRuleCall_2_0(), semanticObject.getHeaderValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Headers returns Headers
	 *
	 * Constraint:
	 *     (headers+=Header headers+=Header*)
	 */
	protected void sequence_Headers(ISerializationContext context, Headers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListElementAlias returns ListElementAlias
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ListElementAlias(ISerializationContext context, ListElementAlias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LIST_ELEMENT_ALIAS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LIST_ELEMENT_ALIAS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListElementAliasAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListElementReference returns ListElementReference
	 *
	 * Constraint:
	 *     (name=[ListElementAlias|ID] prop=PropertyRef?)
	 */
	protected void sequence_ListElementReference(ISerializationContext context, ListElementReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListFunction returns ListFunction
	 *
	 * Constraint:
	 *     (op=ListOperation alias=ListElementAlias separator=':' condition=Condition)
	 */
	protected void sequence_ListFunction(ISerializationContext context, ListFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LIST_FUNCTION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LIST_FUNCTION__OP));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LIST_FUNCTION__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LIST_FUNCTION__ALIAS));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LIST_FUNCTION__SEPARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LIST_FUNCTION__SEPARATOR));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LIST_FUNCTION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LIST_FUNCTION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListFunctionAccess().getOpListOperationEnumRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getListFunctionAccess().getAliasListElementAliasParserRuleCall_2_0(), semanticObject.getAlias());
		feeder.accept(grammarAccess.getListFunctionAccess().getSeparatorColonKeyword_3_0(), semanticObject.getSeparator());
		feeder.accept(grammarAccess.getListFunctionAccess().getConditionConditionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Operand
	 *
	 * Constraint:
	 *     (ref=Reference | const=Constant | listElementRef=ListElementReference)
	 */
	protected void sequence_Operand(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Negation
	 *     OrCondition returns Negation
	 *     OrCondition.OrCondition_1_0 returns Negation
	 *     AndCondition returns Negation
	 *     AndCondition.AndCondition_1_0 returns Negation
	 *     OptionalNegationCondition returns Negation
	 *
	 * Constraint:
	 *     negated=BracketedCondition
	 */
	protected void sequence_OptionalNegationCondition(ISerializationContext context, Negation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.NEGATION__NEGATED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.NEGATION__NEGATED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionalNegationConditionAccess().getNegatedBracketedConditionParserRuleCall_1_2_0(), semanticObject.getNegated());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns OrCondition
	 *     OrCondition returns OrCondition
	 *     OrCondition.OrCondition_1_0 returns OrCondition
	 *
	 * Constraint:
	 *     (left=OrCondition_OrCondition_1_0 right=AndCondition)
	 */
	protected void sequence_OrCondition(ISerializationContext context, OrCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.OR_CONDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.OR_CONDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.OR_CONDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.OR_CONDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrConditionAccess().getOrConditionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrConditionAccess().getRightAndConditionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyAccess returns PropertyAccess
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PropertyAccess(ISerializationContext context, PropertyAccess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROPERTY_ACCESS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROPERTY_ACCESS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccessAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyRef returns PropertyRef
	 *
	 * Constraint:
	 *     ((propAccess=PropertyAccess | functionCall=FunctionCall | collectionAccess=CollectionAccess | listFunc=ListFunction) subPropery=PropertyRef?)
	 */
	protected void sequence_PropertyRef(ISerializationContext context, PropertyRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProxyConf returns ProxyConf
	 *
	 * Constraint:
	 *     proxyUrl=STRING
	 */
	protected void sequence_ProxyConf(ISerializationContext context, ProxyConf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROXY_CONF__PROXY_URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROXY_CONF__PROXY_URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProxyConfAccess().getProxyUrlSTRINGTerminalRuleCall_1_0(), semanticObject.getProxyUrl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (name=Entity prop=PropertyRef?)
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResponseConf returns ResponseConf
	 *
	 * Constraint:
	 *     (httpStatus=INTEGER | content=STRING | headers=Headers)*
	 */
	protected void sequence_ResponseConf(ISerializationContext context, ResponseConf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (conditions=Condition (proxy=ProxyConf | response=ResponseConf)?)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
