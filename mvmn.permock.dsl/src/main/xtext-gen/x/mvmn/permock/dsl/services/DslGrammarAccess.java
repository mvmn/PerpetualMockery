/*
 * generated by Xtext 2.25.0
 */
package x.mvmn.permock.dsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class DslGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class RuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Rule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionsConditionParserRuleCall_1_0 = (RuleCall)cConditionsAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cProxyKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cProxyAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cProxyProxyConfParserRuleCall_2_0_1_0 = (RuleCall)cProxyAssignment_2_0_1.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cRespondKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Keyword cWithKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final Assignment cResponseAssignment_2_1_2 = (Assignment)cGroup_2_1.eContents().get(2);
		private final RuleCall cResponseResponseConfParserRuleCall_2_1_2_0 = (RuleCall)cResponseAssignment_2_1_2.eContents().get(0);
		
		//Rule:
		//    'if' conditions=Condition
		//    ('proxy' proxy=ProxyConf | 'respond' 'with' response=ResponseConf)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'if' conditions=Condition
		//('proxy' proxy=ProxyConf | 'respond' 'with' response=ResponseConf)?
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//conditions=Condition
		public Assignment getConditionsAssignment_1() { return cConditionsAssignment_1; }
		
		//Condition
		public RuleCall getConditionsConditionParserRuleCall_1_0() { return cConditionsConditionParserRuleCall_1_0; }
		
		//('proxy' proxy=ProxyConf | 'respond' 'with' response=ResponseConf)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'proxy' proxy=ProxyConf
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//'proxy'
		public Keyword getProxyKeyword_2_0_0() { return cProxyKeyword_2_0_0; }
		
		//proxy=ProxyConf
		public Assignment getProxyAssignment_2_0_1() { return cProxyAssignment_2_0_1; }
		
		//ProxyConf
		public RuleCall getProxyProxyConfParserRuleCall_2_0_1_0() { return cProxyProxyConfParserRuleCall_2_0_1_0; }
		
		//'respond' 'with' response=ResponseConf
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//'respond'
		public Keyword getRespondKeyword_2_1_0() { return cRespondKeyword_2_1_0; }
		
		//'with'
		public Keyword getWithKeyword_2_1_1() { return cWithKeyword_2_1_1; }
		
		//response=ResponseConf
		public Assignment getResponseAssignment_2_1_2() { return cResponseAssignment_2_1_2; }
		
		//ResponseConf
		public RuleCall getResponseResponseConfParserRuleCall_2_1_2_0() { return cResponseResponseConfParserRuleCall_2_1_2_0; }
	}
	public class ProxyConfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.ProxyConf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUrlKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProxyUrlAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProxyUrlSTRINGTerminalRuleCall_1_0 = (RuleCall)cProxyUrlAssignment_1.eContents().get(0);
		
		//ProxyConf:
		//    'url' proxyUrl=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'url' proxyUrl=STRING
		public Group getGroup() { return cGroup; }
		
		//'url'
		public Keyword getUrlKeyword_0() { return cUrlKeyword_0; }
		
		//proxyUrl=STRING
		public Assignment getProxyUrlAssignment_1() { return cProxyUrlAssignment_1; }
		
		//STRING
		public RuleCall getProxyUrlSTRINGTerminalRuleCall_1_0() { return cProxyUrlSTRINGTerminalRuleCall_1_0; }
	}
	public class ResponseConfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.ResponseConf");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cUnorderedGroup.eContents().get(0);
		private final Keyword cStatusKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cHttpStatusAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cHttpStatusINTEGERTerminalRuleCall_0_1_0 = (RuleCall)cHttpStatusAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cUnorderedGroup.eContents().get(1);
		private final Keyword cContentKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cContentAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cContentSTRINGTerminalRuleCall_1_1_0 = (RuleCall)cContentAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cUnorderedGroup.eContents().get(2);
		private final Keyword cHeadersKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cHeadersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cHeadersHeadersParserRuleCall_2_1_0 = (RuleCall)cHeadersAssignment_2_1.eContents().get(0);
		
		//ResponseConf:
		//    ('status' httpStatus=INTEGER)? &
		//    ('content' content=STRING)? & ('headers' headers=Headers?)?;
		@Override public ParserRule getRule() { return rule; }
		
		//('status' httpStatus=INTEGER)? &
		//('content' content=STRING)? & ('headers' headers=Headers?)?
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }
		
		//('status' httpStatus=INTEGER)?
		public Group getGroup_0() { return cGroup_0; }
		
		//'status'
		public Keyword getStatusKeyword_0_0() { return cStatusKeyword_0_0; }
		
		//httpStatus=INTEGER
		public Assignment getHttpStatusAssignment_0_1() { return cHttpStatusAssignment_0_1; }
		
		//INTEGER
		public RuleCall getHttpStatusINTEGERTerminalRuleCall_0_1_0() { return cHttpStatusINTEGERTerminalRuleCall_0_1_0; }
		
		//('content' content=STRING)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'content'
		public Keyword getContentKeyword_1_0() { return cContentKeyword_1_0; }
		
		//content=STRING
		public Assignment getContentAssignment_1_1() { return cContentAssignment_1_1; }
		
		//STRING
		public RuleCall getContentSTRINGTerminalRuleCall_1_1_0() { return cContentSTRINGTerminalRuleCall_1_1_0; }
		
		//('headers' headers=Headers?)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'headers'
		public Keyword getHeadersKeyword_2_0() { return cHeadersKeyword_2_0; }
		
		//headers=Headers?
		public Assignment getHeadersAssignment_2_1() { return cHeadersAssignment_2_1; }
		
		//Headers
		public RuleCall getHeadersHeadersParserRuleCall_2_1_0() { return cHeadersHeadersParserRuleCall_2_1_0; }
	}
	public class HeadersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Headers");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadersAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadersHeaderParserRuleCall_0_0 = (RuleCall)cHeadersAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cHeadersAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cHeadersHeaderParserRuleCall_1_1_0 = (RuleCall)cHeadersAssignment_1_1.eContents().get(0);
		
		//Headers:
		//    headers+=Header (',' headers+=Header)*;
		@Override public ParserRule getRule() { return rule; }
		
		//headers+=Header (',' headers+=Header)*
		public Group getGroup() { return cGroup; }
		
		//headers+=Header
		public Assignment getHeadersAssignment_0() { return cHeadersAssignment_0; }
		
		//Header
		public RuleCall getHeadersHeaderParserRuleCall_0_0() { return cHeadersHeaderParserRuleCall_0_0; }
		
		//(',' headers+=Header)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//headers+=Header
		public Assignment getHeadersAssignment_1_1() { return cHeadersAssignment_1_1; }
		
		//Header
		public RuleCall getHeadersHeaderParserRuleCall_1_1_0() { return cHeadersHeaderParserRuleCall_1_1_0; }
	}
	public class HeaderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Header");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeaderNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeaderNameSTRINGTerminalRuleCall_0_0 = (RuleCall)cHeaderNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cHeaderValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cHeaderValueSTRINGTerminalRuleCall_2_0 = (RuleCall)cHeaderValueAssignment_2.eContents().get(0);
		
		//Header:
		//    headerName=STRING ':' headerValue=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//headerName=STRING ':' headerValue=STRING
		public Group getGroup() { return cGroup; }
		
		//headerName=STRING
		public Assignment getHeaderNameAssignment_0() { return cHeaderNameAssignment_0; }
		
		//STRING
		public RuleCall getHeaderNameSTRINGTerminalRuleCall_0_0() { return cHeaderNameSTRINGTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//headerValue=STRING
		public Assignment getHeaderValueAssignment_2() { return cHeaderValueAssignment_2; }
		
		//STRING
		public RuleCall getHeaderValueSTRINGTerminalRuleCall_2_0() { return cHeaderValueSTRINGTerminalRuleCall_2_0; }
	}
	public class ConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Condition");
		private final RuleCall cOrConditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Condition:
		//    OrCondition;
		@Override public ParserRule getRule() { return rule; }
		
		//OrCondition
		public RuleCall getOrConditionParserRuleCall() { return cOrConditionParserRuleCall; }
	}
	public class OrConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.OrCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndConditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrConditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndConditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//OrCondition returns Condition:
		//    AndCondition ({OrCondition.left=current} 'or' right=AndCondition)*;
		@Override public ParserRule getRule() { return rule; }
		
		//AndCondition ({OrCondition.left=current} 'or' right=AndCondition)*
		public Group getGroup() { return cGroup; }
		
		//AndCondition
		public RuleCall getAndConditionParserRuleCall_0() { return cAndConditionParserRuleCall_0; }
		
		//({OrCondition.left=current} 'or' right=AndCondition)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{OrCondition.left=current}
		public Action getOrConditionLeftAction_1_0() { return cOrConditionLeftAction_1_0; }
		
		//'or'
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=AndCondition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//AndCondition
		public RuleCall getRightAndConditionParserRuleCall_1_2_0() { return cRightAndConditionParserRuleCall_1_2_0; }
	}
	public class AndConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.AndCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOptionalNegationConditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndConditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOptionalNegationConditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndCondition returns Condition:
		//    OptionalNegationCondition ({AndCondition.left=current} 'and' right=OptionalNegationCondition)*;
		@Override public ParserRule getRule() { return rule; }
		
		//OptionalNegationCondition ({AndCondition.left=current} 'and' right=OptionalNegationCondition)*
		public Group getGroup() { return cGroup; }
		
		//OptionalNegationCondition
		public RuleCall getOptionalNegationConditionParserRuleCall_0() { return cOptionalNegationConditionParserRuleCall_0; }
		
		//({AndCondition.left=current} 'and' right=OptionalNegationCondition)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AndCondition.left=current}
		public Action getAndConditionLeftAction_1_0() { return cAndConditionLeftAction_1_0; }
		
		//'and'
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=OptionalNegationCondition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//OptionalNegationCondition
		public RuleCall getRightOptionalNegationConditionParserRuleCall_1_2_0() { return cRightOptionalNegationConditionParserRuleCall_1_2_0; }
	}
	public class OptionalNegationConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.OptionalNegationCondition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBracketedConditionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNegationAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cNotKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNegatedAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cNegatedBracketedConditionParserRuleCall_1_2_0 = (RuleCall)cNegatedAssignment_1_2.eContents().get(0);
		
		//OptionalNegationCondition returns Condition:
		//    BracketedCondition | {Negation} 'not' negated=BracketedCondition;
		@Override public ParserRule getRule() { return rule; }
		
		//BracketedCondition | {Negation} 'not' negated=BracketedCondition
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BracketedCondition
		public RuleCall getBracketedConditionParserRuleCall_0() { return cBracketedConditionParserRuleCall_0; }
		
		//{Negation} 'not' negated=BracketedCondition
		public Group getGroup_1() { return cGroup_1; }
		
		//{Negation}
		public Action getNegationAction_1_0() { return cNegationAction_1_0; }
		
		//'not'
		public Keyword getNotKeyword_1_1() { return cNotKeyword_1_1; }
		
		//negated=BracketedCondition
		public Assignment getNegatedAssignment_1_2() { return cNegatedAssignment_1_2; }
		
		//BracketedCondition
		public RuleCall getNegatedBracketedConditionParserRuleCall_1_2_0() { return cNegatedBracketedConditionParserRuleCall_1_2_0; }
	}
	public class BracketedConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.BracketedCondition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConditionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConditionConditionParserRuleCall_1_1_0 = (RuleCall)cConditionAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//BracketedCondition returns Condition:
		//    expression=Expression | '(' condition=Condition ')';
		@Override public ParserRule getRule() { return rule; }
		
		//expression=Expression | '(' condition=Condition ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }
		
		//'(' condition=Condition ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//condition=Condition
		public Assignment getConditionAssignment_1_1() { return cConditionAssignment_1_1; }
		
		//Condition
		public RuleCall getConditionConditionParserRuleCall_1_1_0() { return cConditionConditionParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftOperandParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOpAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOpOperatorEnumRuleCall_1_0_0 = (RuleCall)cOpAssignment_1_0.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightOperandParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Expression:
		//    left=Operand (op=Operator right=Operand)?;
		@Override public ParserRule getRule() { return rule; }
		
		//left=Operand (op=Operator right=Operand)?
		public Group getGroup() { return cGroup; }
		
		//left=Operand
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//Operand
		public RuleCall getLeftOperandParserRuleCall_0_0() { return cLeftOperandParserRuleCall_0_0; }
		
		//(op=Operator right=Operand)?
		public Group getGroup_1() { return cGroup_1; }
		
		//op=Operator
		public Assignment getOpAssignment_1_0() { return cOpAssignment_1_0; }
		
		//Operator
		public RuleCall getOpOperatorEnumRuleCall_1_0_0() { return cOpOperatorEnumRuleCall_1_0_0; }
		
		//right=Operand
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Operand
		public RuleCall getRightOperandParserRuleCall_1_1_0() { return cRightOperandParserRuleCall_1_1_0; }
	}
	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cRefReferenceParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Assignment cConstAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cConstConstantParserRuleCall_1_0 = (RuleCall)cConstAssignment_1.eContents().get(0);
		private final Assignment cListElementRefAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cListElementRefListElementReferenceParserRuleCall_2_0 = (RuleCall)cListElementRefAssignment_2.eContents().get(0);
		
		//Operand:
		//    ref=Reference | const=Constant | listElementRef=ListElementReference;
		@Override public ParserRule getRule() { return rule; }
		
		//ref=Reference | const=Constant | listElementRef=ListElementReference
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ref=Reference
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }
		
		//Reference
		public RuleCall getRefReferenceParserRuleCall_0_0() { return cRefReferenceParserRuleCall_0_0; }
		
		//const=Constant
		public Assignment getConstAssignment_1() { return cConstAssignment_1; }
		
		//Constant
		public RuleCall getConstConstantParserRuleCall_1_0() { return cConstConstantParserRuleCall_1_0; }
		
		//listElementRef=ListElementReference
		public Assignment getListElementRefAssignment_2() { return cListElementRefAssignment_2; }
		
		//ListElementReference
		public RuleCall getListElementRefListElementReferenceParserRuleCall_2_0() { return cListElementRefListElementReferenceParserRuleCall_2_0; }
	}
	public class ListFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.ListFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpListOperationEnumRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cAliasAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAliasListElementAliasParserRuleCall_2_0 = (RuleCall)cAliasAssignment_2.eContents().get(0);
		private final Assignment cSeparatorAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cSeparatorColonKeyword_3_0 = (Keyword)cSeparatorAssignment_3.eContents().get(0);
		private final Assignment cConditionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConditionConditionParserRuleCall_4_0 = (RuleCall)cConditionAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ListFunction:
		//    '{' op=ListOperation alias=ListElementAlias separator=':' condition=Condition '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'{' op=ListOperation alias=ListElementAlias separator=':' condition=Condition '}'
		public Group getGroup() { return cGroup; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }
		
		//op=ListOperation
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }
		
		//ListOperation
		public RuleCall getOpListOperationEnumRuleCall_1_0() { return cOpListOperationEnumRuleCall_1_0; }
		
		//alias=ListElementAlias
		public Assignment getAliasAssignment_2() { return cAliasAssignment_2; }
		
		//ListElementAlias
		public RuleCall getAliasListElementAliasParserRuleCall_2_0() { return cAliasListElementAliasParserRuleCall_2_0; }
		
		//separator=':'
		public Assignment getSeparatorAssignment_3() { return cSeparatorAssignment_3; }
		
		//':'
		public Keyword getSeparatorColonKeyword_3_0() { return cSeparatorColonKeyword_3_0; }
		
		//condition=Condition
		public Assignment getConditionAssignment_4() { return cConditionAssignment_4; }
		
		//Condition
		public RuleCall getConditionConditionParserRuleCall_4_0() { return cConditionConditionParserRuleCall_4_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class ListElementAliasElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.ListElementAlias");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ListElementAlias:
		//    name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Reference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameEntityParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cPropAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPropPropertyRefParserRuleCall_1_0 = (RuleCall)cPropAssignment_1.eContents().get(0);
		
		//Reference hidden(WS):
		//    name=Entity (prop=PropertyRef)?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=Entity (prop=PropertyRef)?
		public Group getGroup() { return cGroup; }
		
		//name=Entity
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//Entity
		public RuleCall getNameEntityParserRuleCall_0_0() { return cNameEntityParserRuleCall_0_0; }
		
		//(prop=PropertyRef)?
		public Assignment getPropAssignment_1() { return cPropAssignment_1; }
		
		//PropertyRef
		public RuleCall getPropPropertyRefParserRuleCall_1_0() { return cPropPropertyRefParserRuleCall_1_0; }
	}
	public class ListElementReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.ListElementReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDollarSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameListElementAliasCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameListElementAliasIDTerminalRuleCall_1_0_1 = (RuleCall)cNameListElementAliasCrossReference_1_0.eContents().get(1);
		private final Assignment cPropAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPropPropertyRefParserRuleCall_2_0 = (RuleCall)cPropAssignment_2.eContents().get(0);
		
		//ListElementReference hidden(WS):
		//    '$' name=[ListElementAlias|ID] (prop=PropertyRef)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'$' name=[ListElementAlias|ID] (prop=PropertyRef)?
		public Group getGroup() { return cGroup; }
		
		//'$'
		public Keyword getDollarSignKeyword_0() { return cDollarSignKeyword_0; }
		
		//name=[ListElementAlias|ID]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//[ListElementAlias|ID]
		public CrossReference getNameListElementAliasCrossReference_1_0() { return cNameListElementAliasCrossReference_1_0; }
		
		//ID
		public RuleCall getNameListElementAliasIDTerminalRuleCall_1_0_1() { return cNameListElementAliasIDTerminalRuleCall_1_0_1; }
		
		//(prop=PropertyRef)?
		public Assignment getPropAssignment_2() { return cPropAssignment_2; }
		
		//PropertyRef
		public RuleCall getPropPropertyRefParserRuleCall_2_0() { return cPropPropertyRefParserRuleCall_2_0; }
	}
	public class CollectionAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.CollectionAccess");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cKeyAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cKeySTRINGTerminalRuleCall_1_0_0 = (RuleCall)cKeyAssignment_1_0.eContents().get(0);
		private final Assignment cIndexAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cIndexINTEGERTerminalRuleCall_1_1_0 = (RuleCall)cIndexAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//CollectionAccess:
		//    '[' (key=STRING | index=INTEGER) ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' (key=STRING | index=INTEGER) ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//(key=STRING | index=INTEGER)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//key=STRING
		public Assignment getKeyAssignment_1_0() { return cKeyAssignment_1_0; }
		
		//STRING
		public RuleCall getKeySTRINGTerminalRuleCall_1_0_0() { return cKeySTRINGTerminalRuleCall_1_0_0; }
		
		//index=INTEGER
		public Assignment getIndexAssignment_1_1() { return cIndexAssignment_1_1; }
		
		//INTEGER
		public RuleCall getIndexINTEGERTerminalRuleCall_1_1_0() { return cIndexINTEGERTerminalRuleCall_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class PropertyAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.PropertyAccess");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//PropertyAccess:
		//    name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFunctionParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFunctionParametersOperandParserRuleCall_2_0 = (RuleCall)cFunctionParametersAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFunctionParametersAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFunctionParametersOperandParserRuleCall_3_1_0 = (RuleCall)cFunctionParametersAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//FunctionCall:
		//    name=ID '(' functionParameters+=Operand? (',' functionParameters+=Operand)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '(' functionParameters+=Operand? (',' functionParameters+=Operand)* ')'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//functionParameters+=Operand?
		public Assignment getFunctionParametersAssignment_2() { return cFunctionParametersAssignment_2; }
		
		//Operand
		public RuleCall getFunctionParametersOperandParserRuleCall_2_0() { return cFunctionParametersOperandParserRuleCall_2_0; }
		
		//(',' functionParameters+=Operand)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//functionParameters+=Operand
		public Assignment getFunctionParametersAssignment_3_1() { return cFunctionParametersAssignment_3_1; }
		
		//Operand
		public RuleCall getFunctionParametersOperandParserRuleCall_3_1_0() { return cFunctionParametersOperandParserRuleCall_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class PropertyRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.PropertyRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Assignment cPropAccessAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cPropAccessPropertyAccessParserRuleCall_0_0_1_0 = (RuleCall)cPropAccessAssignment_0_0_1.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cFullStopKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cFunctionCallAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cFunctionCallFunctionCallParserRuleCall_0_1_1_0 = (RuleCall)cFunctionCallAssignment_0_1_1.eContents().get(0);
		private final Assignment cCollectionAccessAssignment_0_2 = (Assignment)cAlternatives_0.eContents().get(2);
		private final RuleCall cCollectionAccessCollectionAccessParserRuleCall_0_2_0 = (RuleCall)cCollectionAccessAssignment_0_2.eContents().get(0);
		private final Assignment cListFuncAssignment_0_3 = (Assignment)cAlternatives_0.eContents().get(3);
		private final RuleCall cListFuncListFunctionParserRuleCall_0_3_0 = (RuleCall)cListFuncAssignment_0_3.eContents().get(0);
		private final Assignment cSubProperyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSubProperyPropertyRefParserRuleCall_1_0 = (RuleCall)cSubProperyAssignment_1.eContents().get(0);
		
		//PropertyRef hidden(WS):
		//    ('.' propAccess=PropertyAccess | '.' functionCall=FunctionCall | collectionAccess=CollectionAccess |
		//    listFunc=ListFunction)
		//    (subPropery=PropertyRef)?;
		@Override public ParserRule getRule() { return rule; }
		
		//('.' propAccess=PropertyAccess | '.' functionCall=FunctionCall | collectionAccess=CollectionAccess |
		//listFunc=ListFunction)
		//(subPropery=PropertyRef)?
		public Group getGroup() { return cGroup; }
		
		//('.' propAccess=PropertyAccess | '.' functionCall=FunctionCall | collectionAccess=CollectionAccess |
		//listFunc=ListFunction)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'.' propAccess=PropertyAccess
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//'.'
		public Keyword getFullStopKeyword_0_0_0() { return cFullStopKeyword_0_0_0; }
		
		//propAccess=PropertyAccess
		public Assignment getPropAccessAssignment_0_0_1() { return cPropAccessAssignment_0_0_1; }
		
		//PropertyAccess
		public RuleCall getPropAccessPropertyAccessParserRuleCall_0_0_1_0() { return cPropAccessPropertyAccessParserRuleCall_0_0_1_0; }
		
		//'.' functionCall=FunctionCall
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_0_1_0() { return cFullStopKeyword_0_1_0; }
		
		//functionCall=FunctionCall
		public Assignment getFunctionCallAssignment_0_1_1() { return cFunctionCallAssignment_0_1_1; }
		
		//FunctionCall
		public RuleCall getFunctionCallFunctionCallParserRuleCall_0_1_1_0() { return cFunctionCallFunctionCallParserRuleCall_0_1_1_0; }
		
		//collectionAccess=CollectionAccess
		public Assignment getCollectionAccessAssignment_0_2() { return cCollectionAccessAssignment_0_2; }
		
		//CollectionAccess
		public RuleCall getCollectionAccessCollectionAccessParserRuleCall_0_2_0() { return cCollectionAccessCollectionAccessParserRuleCall_0_2_0; }
		
		//listFunc=ListFunction
		public Assignment getListFuncAssignment_0_3() { return cListFuncAssignment_0_3; }
		
		//ListFunction
		public RuleCall getListFuncListFunctionParserRuleCall_0_3_0() { return cListFuncListFunctionParserRuleCall_0_3_0; }
		
		//(subPropery=PropertyRef)?
		public Assignment getSubProperyAssignment_1() { return cSubProperyAssignment_1; }
		
		//PropertyRef
		public RuleCall getSubProperyPropertyRefParserRuleCall_1_0() { return cSubProperyPropertyRefParserRuleCall_1_0; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cStrValAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cStrValSTRINGTerminalRuleCall_0_0 = (RuleCall)cStrValAssignment_0.eContents().get(0);
		private final Assignment cIntValAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cIntValINTEGERTerminalRuleCall_1_0 = (RuleCall)cIntValAssignment_1.eContents().get(0);
		private final Assignment cFloatValAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cFloatValFLOATTerminalRuleCall_2_0 = (RuleCall)cFloatValAssignment_2.eContents().get(0);
		private final Assignment cBoolValAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cBoolValBOOLEANTerminalRuleCall_3_0 = (RuleCall)cBoolValAssignment_3.eContents().get(0);
		
		//Constant:
		//    strVal=STRING | intVal=INTEGER | floatVal=FLOAT | boolVal=BOOLEAN;
		@Override public ParserRule getRule() { return rule; }
		
		//strVal=STRING | intVal=INTEGER | floatVal=FLOAT | boolVal=BOOLEAN
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//strVal=STRING
		public Assignment getStrValAssignment_0() { return cStrValAssignment_0; }
		
		//STRING
		public RuleCall getStrValSTRINGTerminalRuleCall_0_0() { return cStrValSTRINGTerminalRuleCall_0_0; }
		
		//intVal=INTEGER
		public Assignment getIntValAssignment_1() { return cIntValAssignment_1; }
		
		//INTEGER
		public RuleCall getIntValINTEGERTerminalRuleCall_1_0() { return cIntValINTEGERTerminalRuleCall_1_0; }
		
		//floatVal=FLOAT
		public Assignment getFloatValAssignment_2() { return cFloatValAssignment_2; }
		
		//FLOAT
		public RuleCall getFloatValFLOATTerminalRuleCall_2_0() { return cFloatValFLOATTerminalRuleCall_2_0; }
		
		//boolVal=BOOLEAN
		public Assignment getBoolValAssignment_3() { return cBoolValAssignment_3; }
		
		//BOOLEAN
		public RuleCall getBoolValBOOLEANTerminalRuleCall_3_0() { return cBoolValBOOLEANTerminalRuleCall_3_0; }
	}
	public class EntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Entity");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Entity:
		//    name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	
	public class OperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEQEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNEQExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNEQEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGTGreaterThanSignKeyword_2_0 = (Keyword)cGTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGTEQEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGTEQGreaterThanSignEqualsSignKeyword_3_0 = (Keyword)cGTEQEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cLTLessThanSignKeyword_4_0 = (Keyword)cLTEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cLTEQEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cLTEQLessThanSignEqualsSignKeyword_5_0 = (Keyword)cLTEQEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cREGEXEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cREGEXTildeEqualsSignKeyword_6_0 = (Keyword)cREGEXEnumLiteralDeclaration_6.eContents().get(0);
		
		//enum Operator:
		//    EQ='=' | NEQ='!=' | GT='>' | GTEQ='>=' | LT='<' | LTEQ='<=' | REGEX='~=';
		public EnumRule getRule() { return rule; }
		
		//EQ='=' | NEQ='!=' | GT='>' | GTEQ='>=' | LT='<' | LTEQ='<=' | REGEX='~='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQ='='
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }
		
		//'='
		public Keyword getEQEqualsSignKeyword_0_0() { return cEQEqualsSignKeyword_0_0; }
		
		//NEQ='!='
		public EnumLiteralDeclaration getNEQEnumLiteralDeclaration_1() { return cNEQEnumLiteralDeclaration_1; }
		
		//'!='
		public Keyword getNEQExclamationMarkEqualsSignKeyword_1_0() { return cNEQExclamationMarkEqualsSignKeyword_1_0; }
		
		//GT='>'
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_2() { return cGTEnumLiteralDeclaration_2; }
		
		//'>'
		public Keyword getGTGreaterThanSignKeyword_2_0() { return cGTGreaterThanSignKeyword_2_0; }
		
		//GTEQ='>='
		public EnumLiteralDeclaration getGTEQEnumLiteralDeclaration_3() { return cGTEQEnumLiteralDeclaration_3; }
		
		//'>='
		public Keyword getGTEQGreaterThanSignEqualsSignKeyword_3_0() { return cGTEQGreaterThanSignEqualsSignKeyword_3_0; }
		
		//LT='<'
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_4() { return cLTEnumLiteralDeclaration_4; }
		
		//'<'
		public Keyword getLTLessThanSignKeyword_4_0() { return cLTLessThanSignKeyword_4_0; }
		
		//LTEQ='<='
		public EnumLiteralDeclaration getLTEQEnumLiteralDeclaration_5() { return cLTEQEnumLiteralDeclaration_5; }
		
		//'<='
		public Keyword getLTEQLessThanSignEqualsSignKeyword_5_0() { return cLTEQLessThanSignEqualsSignKeyword_5_0; }
		
		//REGEX='~='
		public EnumLiteralDeclaration getREGEXEnumLiteralDeclaration_6() { return cREGEXEnumLiteralDeclaration_6; }
		
		//'~='
		public Keyword getREGEXTildeEqualsSignKeyword_6_0() { return cREGEXTildeEqualsSignKeyword_6_0; }
	}
	public class ListOperationElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.ListOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFILTEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFILTERWhereKeyword_0_0 = (Keyword)cFILTEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cALLEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cALLAllKeyword_1_0 = (Keyword)cALLEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cANYEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cANYAnyKeyword_2_0 = (Keyword)cANYEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ListOperation:
		//    FILTER='where' | ALL='all' | ANY='any';
		public EnumRule getRule() { return rule; }
		
		//FILTER='where' | ALL='all' | ANY='any'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FILTER='where'
		public EnumLiteralDeclaration getFILTEREnumLiteralDeclaration_0() { return cFILTEREnumLiteralDeclaration_0; }
		
		//'where'
		public Keyword getFILTERWhereKeyword_0_0() { return cFILTERWhereKeyword_0_0; }
		
		//ALL='all'
		public EnumLiteralDeclaration getALLEnumLiteralDeclaration_1() { return cALLEnumLiteralDeclaration_1; }
		
		//'all'
		public Keyword getALLAllKeyword_1_0() { return cALLAllKeyword_1_0; }
		
		//ANY='any'
		public EnumLiteralDeclaration getANYEnumLiteralDeclaration_2() { return cANYEnumLiteralDeclaration_2; }
		
		//'any'
		public Keyword getANYAnyKeyword_2_0() { return cANYAnyKeyword_2_0; }
	}
	
	private final RuleElements pRule;
	private final ProxyConfElements pProxyConf;
	private final ResponseConfElements pResponseConf;
	private final HeadersElements pHeaders;
	private final HeaderElements pHeader;
	private final ConditionElements pCondition;
	private final OrConditionElements pOrCondition;
	private final AndConditionElements pAndCondition;
	private final OptionalNegationConditionElements pOptionalNegationCondition;
	private final BracketedConditionElements pBracketedCondition;
	private final ExpressionElements pExpression;
	private final OperandElements pOperand;
	private final ListFunctionElements pListFunction;
	private final ListElementAliasElements pListElementAlias;
	private final ReferenceElements pReference;
	private final ListElementReferenceElements pListElementReference;
	private final CollectionAccessElements pCollectionAccess;
	private final PropertyAccessElements pPropertyAccess;
	private final FunctionCallElements pFunctionCall;
	private final PropertyRefElements pPropertyRef;
	private final OperatorElements eOperator;
	private final ConstantElements pConstant;
	private final ListOperationElements eListOperation;
	private final EntityElements pEntity;
	private final TerminalRule tBOOLEAN;
	private final TerminalRule tFLOAT;
	private final TerminalRule tINTEGER;
	private final TerminalRule tID;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public DslGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pRule = new RuleElements();
		this.pProxyConf = new ProxyConfElements();
		this.pResponseConf = new ResponseConfElements();
		this.pHeaders = new HeadersElements();
		this.pHeader = new HeaderElements();
		this.pCondition = new ConditionElements();
		this.pOrCondition = new OrConditionElements();
		this.pAndCondition = new AndConditionElements();
		this.pOptionalNegationCondition = new OptionalNegationConditionElements();
		this.pBracketedCondition = new BracketedConditionElements();
		this.pExpression = new ExpressionElements();
		this.pOperand = new OperandElements();
		this.pListFunction = new ListFunctionElements();
		this.pListElementAlias = new ListElementAliasElements();
		this.pReference = new ReferenceElements();
		this.pListElementReference = new ListElementReferenceElements();
		this.pCollectionAccess = new CollectionAccessElements();
		this.pPropertyAccess = new PropertyAccessElements();
		this.pFunctionCall = new FunctionCallElements();
		this.pPropertyRef = new PropertyRefElements();
		this.eOperator = new OperatorElements();
		this.pConstant = new ConstantElements();
		this.eListOperation = new ListOperationElements();
		this.pEntity = new EntityElements();
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.BOOLEAN");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.FLOAT");
		this.tINTEGER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.INTEGER");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.ID");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "x.mvmn.permock.dsl.Dsl.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("x.mvmn.permock.dsl.Dsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Rule:
	//    'if' conditions=Condition
	//    ('proxy' proxy=ProxyConf | 'respond' 'with' response=ResponseConf)?;
	public RuleElements getRuleAccess() {
		return pRule;
	}
	
	public ParserRule getRuleRule() {
		return getRuleAccess().getRule();
	}
	
	//ProxyConf:
	//    'url' proxyUrl=STRING;
	public ProxyConfElements getProxyConfAccess() {
		return pProxyConf;
	}
	
	public ParserRule getProxyConfRule() {
		return getProxyConfAccess().getRule();
	}
	
	//ResponseConf:
	//    ('status' httpStatus=INTEGER)? &
	//    ('content' content=STRING)? & ('headers' headers=Headers?)?;
	public ResponseConfElements getResponseConfAccess() {
		return pResponseConf;
	}
	
	public ParserRule getResponseConfRule() {
		return getResponseConfAccess().getRule();
	}
	
	//Headers:
	//    headers+=Header (',' headers+=Header)*;
	public HeadersElements getHeadersAccess() {
		return pHeaders;
	}
	
	public ParserRule getHeadersRule() {
		return getHeadersAccess().getRule();
	}
	
	//Header:
	//    headerName=STRING ':' headerValue=STRING;
	public HeaderElements getHeaderAccess() {
		return pHeader;
	}
	
	public ParserRule getHeaderRule() {
		return getHeaderAccess().getRule();
	}
	
	//Condition:
	//    OrCondition;
	public ConditionElements getConditionAccess() {
		return pCondition;
	}
	
	public ParserRule getConditionRule() {
		return getConditionAccess().getRule();
	}
	
	//OrCondition returns Condition:
	//    AndCondition ({OrCondition.left=current} 'or' right=AndCondition)*;
	public OrConditionElements getOrConditionAccess() {
		return pOrCondition;
	}
	
	public ParserRule getOrConditionRule() {
		return getOrConditionAccess().getRule();
	}
	
	//AndCondition returns Condition:
	//    OptionalNegationCondition ({AndCondition.left=current} 'and' right=OptionalNegationCondition)*;
	public AndConditionElements getAndConditionAccess() {
		return pAndCondition;
	}
	
	public ParserRule getAndConditionRule() {
		return getAndConditionAccess().getRule();
	}
	
	//OptionalNegationCondition returns Condition:
	//    BracketedCondition | {Negation} 'not' negated=BracketedCondition;
	public OptionalNegationConditionElements getOptionalNegationConditionAccess() {
		return pOptionalNegationCondition;
	}
	
	public ParserRule getOptionalNegationConditionRule() {
		return getOptionalNegationConditionAccess().getRule();
	}
	
	//BracketedCondition returns Condition:
	//    expression=Expression | '(' condition=Condition ')';
	public BracketedConditionElements getBracketedConditionAccess() {
		return pBracketedCondition;
	}
	
	public ParserRule getBracketedConditionRule() {
		return getBracketedConditionAccess().getRule();
	}
	
	//Expression:
	//    left=Operand (op=Operator right=Operand)?;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Operand:
	//    ref=Reference | const=Constant | listElementRef=ListElementReference;
	public OperandElements getOperandAccess() {
		return pOperand;
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}
	
	//ListFunction:
	//    '{' op=ListOperation alias=ListElementAlias separator=':' condition=Condition '}';
	public ListFunctionElements getListFunctionAccess() {
		return pListFunction;
	}
	
	public ParserRule getListFunctionRule() {
		return getListFunctionAccess().getRule();
	}
	
	//ListElementAlias:
	//    name=ID;
	public ListElementAliasElements getListElementAliasAccess() {
		return pListElementAlias;
	}
	
	public ParserRule getListElementAliasRule() {
		return getListElementAliasAccess().getRule();
	}
	
	//Reference hidden(WS):
	//    name=Entity (prop=PropertyRef)?;
	public ReferenceElements getReferenceAccess() {
		return pReference;
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}
	
	//ListElementReference hidden(WS):
	//    '$' name=[ListElementAlias|ID] (prop=PropertyRef)?;
	public ListElementReferenceElements getListElementReferenceAccess() {
		return pListElementReference;
	}
	
	public ParserRule getListElementReferenceRule() {
		return getListElementReferenceAccess().getRule();
	}
	
	//CollectionAccess:
	//    '[' (key=STRING | index=INTEGER) ']';
	public CollectionAccessElements getCollectionAccessAccess() {
		return pCollectionAccess;
	}
	
	public ParserRule getCollectionAccessRule() {
		return getCollectionAccessAccess().getRule();
	}
	
	//PropertyAccess:
	//    name=ID;
	public PropertyAccessElements getPropertyAccessAccess() {
		return pPropertyAccess;
	}
	
	public ParserRule getPropertyAccessRule() {
		return getPropertyAccessAccess().getRule();
	}
	
	//FunctionCall:
	//    name=ID '(' functionParameters+=Operand? (',' functionParameters+=Operand)* ')';
	public FunctionCallElements getFunctionCallAccess() {
		return pFunctionCall;
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}
	
	//PropertyRef hidden(WS):
	//    ('.' propAccess=PropertyAccess | '.' functionCall=FunctionCall | collectionAccess=CollectionAccess |
	//    listFunc=ListFunction)
	//    (subPropery=PropertyRef)?;
	public PropertyRefElements getPropertyRefAccess() {
		return pPropertyRef;
	}
	
	public ParserRule getPropertyRefRule() {
		return getPropertyRefAccess().getRule();
	}
	
	//enum Operator:
	//    EQ='=' | NEQ='!=' | GT='>' | GTEQ='>=' | LT='<' | LTEQ='<=' | REGEX='~=';
	public OperatorElements getOperatorAccess() {
		return eOperator;
	}
	
	public EnumRule getOperatorRule() {
		return getOperatorAccess().getRule();
	}
	
	//Constant:
	//    strVal=STRING | intVal=INTEGER | floatVal=FLOAT | boolVal=BOOLEAN;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//enum ListOperation:
	//    FILTER='where' | ALL='all' | ANY='any';
	public ListOperationElements getListOperationAccess() {
		return eListOperation;
	}
	
	public EnumRule getListOperationRule() {
		return getListOperationAccess().getRule();
	}
	
	//Entity:
	//    name=ID;
	public EntityElements getEntityAccess() {
		return pEntity;
	}
	
	public ParserRule getEntityRule() {
		return getEntityAccess().getRule();
	}
	
	//terminal BOOLEAN returns ecore::EBooleanObject:
	//    'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	}
	
	//terminal FLOAT returns ecore::EDoubleObject:
	//    INTEGER '.' INTEGER;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal INTEGER returns ecore::ELongObject:
	//    ('0'..'9')+;
	public TerminalRule getINTEGERRule() {
		return tINTEGER;
	}
	
	//terminal ID:
	//    '^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal STRING:
	//    '"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"' |
	//    "'" ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal ML_COMMENT:
	//    '/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//    '//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//    (' ' | '\t' | '\r' | '\n')+;
	public TerminalRule getWSRule() {
		return tWS;
	}
}
